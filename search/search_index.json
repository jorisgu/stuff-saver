{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"stuff-saver","text":"<p>Just save stuffs</p>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#stuff_saver.StuffSaver","title":"<code>StuffSaver</code>","text":"<p>StuffSaver class to save and reload data from a temporary folder</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>str</code> <p>Path to the temporary folder where the data will be saved.</p> <code>backend</code> <code>_type_</code> <p>Backend to use for saving the data. It should have the methods load and dump.</p> <p>Methods:</p> Name Description <code>exists</code> <p>typing.Hashable) -&gt; bool: Check if the data exists in the temporary folder.</p> <code>reload</code> <p>typing.Hashable) -&gt; typing.Any: Reload the data from the temporary folder.</p> Source code in <code>stuff_saver/stuff_saver.py</code> <pre><code>class StuffSaver:\n    \"\"\"StuffSaver class to save and reload data from a temporary folder\n\n    Attributes:\n        path (str): Path to the temporary folder where the data will be saved.\n        backend (_type_): Backend to use for saving the data. It should have the methods load and dump.\n\n    Methods:\n        exists(request_key: typing.Hashable) -&gt; bool: Check if the data exists in the temporary folder.\n        reload(request_key: typing.Hashable) -&gt; typing.Any: Reload the data from the temporary folder.\n\n\n\n    \"\"\"\n\n    def __init__(self, path: str = \"./tmp\", backend: typing.Any = None):\n        \"\"\"Create a StuffSaver object\n\n        Args:\n            path (str, optional): Path to the temporary folder where the data will be saved. Defaults to \"./tmp\".\n            backend (_type_, optional): Backend to use for saving the data. It should have the methods load and dump. Defaults to None which uses the pickle backend.\n        \"\"\"\n        mkdir_p(path)\n        self.path = path\n\n        if backend is not None:\n            self.backend = backend\n        else:\n            import pickle\n\n            self.backend = pickle\n\n    def exists(self, request_key: typing.Hashable) -&gt; bool:\n        \"\"\"Check if the data exists in the temporary folder.\n\n        Args:\n            request_key (typing.Hashable): request_key key to check if the data exists.\n\n        Returns:\n            bool: True if the data exists in the temporary folder, False otherwise.\n        \"\"\"\n\n        saving_path = os.path.join(self.path, hasher(request_key))\n        return os.path.isfile(saving_path)\n\n    def reload(self, request_key: typing.Hashable) -&gt; typing.Any:\n        \"\"\"\n        Reloads the data associated with the given request_key.\n\n        Parameters:\n            request_key (typing.Hashable): The request_key to reload the data for.\n\n        Returns:\n            typing.Any: The reloaded data.\n\n        Raises:\n            FileNotFoundError: If the file associated with the request_key does not exist.\n            IOError: If there is an error reading the file.\n\n        \"\"\"\n        saving_path = os.path.join(self.path, hasher(request_key))\n        with open(saving_path, \"rb\") as handle:\n            data = self.backend.load(handle)\n        return data\n\n    def save(self, request_key: typing.Hashable, data: typing.Any) -&gt; None:\n        \"\"\"\n        Save the given data to a file.\n\n        Args:\n            request_key (typing.Hashable): The request_key object used to generate the saving path.\n            data (typing.Any): The data to be saved.\n\n        Returns:\n            None\n        \"\"\"\n        saving_path = os.path.join(self.path, hasher(request_key))\n        with open(saving_path, \"wb\") as handle:\n            self.backend.dump(data, handle)\n\n    def reload_folder(self) -&gt; typing.List[typing.Any]:\n        \"\"\"\n        Reloads the folder specified by `self.path` and returns a list of previously saved data.\n\n        Returns:\n            list: A list of loaded data from the files in the folder.\n        \"\"\"\n        list_data = []\n        for filename in os.listdir(self.path):\n            saving_path = os.path.join(self.path, filename)\n            with open(saving_path, \"rb\") as handle:\n                data = self.backend.load(handle)\n            list_data.append(data)\n        return list_data\n\n    def delete(self, request_key: typing.Hashable) -&gt; None:\n        \"\"\"\n        Deletes the file associated with the given request_key.\n        Args:\n            request_key (typing.Hashable): The request_key to delete the file for.\n        Returns:\n            None\n        \"\"\"\n\n        saving_path = os.path.join(self.path, hasher(request_key))\n        if os.path.exists(saving_path):\n            os.remove(saving_path)\n\n    def wrap(\n        self,\n        #\n        request_key: typing.Hashable,\n        fn: typing.Callable[..., typing.Any],\n        *args: typing.Any,\n        **kwargs: dict[str, typing.Any],\n    ) -&gt; typing.Any:\n        \"\"\"\n        Wraps a function call with caching mechanism.\n        Args:\n            request_key (typing.Hashable): The key used to identify the cached result.\n            fn (callable): The function to be wrapped.\n            *args: Positional arguments to be passed to the function.\n            **kwargs: Keyword arguments to be passed to the function.\n        Returns:\n            typing.Any: The result of the function call.\n        Example:\n            &gt;&gt;&gt; def add(a, b):\n            ...     return a + b\n            ...\n            &gt;&gt;&gt; ss = StuffSaver()\n            &gt;&gt;&gt; wrapped_add = ss.wrap(\"add\", add, 2, 3)\n            &gt;&gt;&gt; print(wrapped_add)\n            5\n        \"\"\"\n\n        if self.exists(request_key):\n            return self.reload(request_key)\n        else:\n            result = fn(*args, **kwargs)\n            self.save(request_key, result)\n            return result\n</code></pre>"},{"location":"modules/#stuff_saver.StuffSaver.__init__","title":"<code>__init__(path='./tmp', backend=None)</code>","text":"<p>Create a StuffSaver object</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the temporary folder where the data will be saved. Defaults to \"./tmp\".</p> <code>'./tmp'</code> <code>backend</code> <code>_type_</code> <p>Backend to use for saving the data. It should have the methods load and dump. Defaults to None which uses the pickle backend.</p> <code>None</code> Source code in <code>stuff_saver/stuff_saver.py</code> <pre><code>def __init__(self, path: str = \"./tmp\", backend: typing.Any = None):\n    \"\"\"Create a StuffSaver object\n\n    Args:\n        path (str, optional): Path to the temporary folder where the data will be saved. Defaults to \"./tmp\".\n        backend (_type_, optional): Backend to use for saving the data. It should have the methods load and dump. Defaults to None which uses the pickle backend.\n    \"\"\"\n    mkdir_p(path)\n    self.path = path\n\n    if backend is not None:\n        self.backend = backend\n    else:\n        import pickle\n\n        self.backend = pickle\n</code></pre>"},{"location":"modules/#stuff_saver.StuffSaver.delete","title":"<code>delete(request_key)</code>","text":"<p>Deletes the file associated with the given request_key. Args:     request_key (typing.Hashable): The request_key to delete the file for. Returns:     None</p> Source code in <code>stuff_saver/stuff_saver.py</code> <pre><code>def delete(self, request_key: typing.Hashable) -&gt; None:\n    \"\"\"\n    Deletes the file associated with the given request_key.\n    Args:\n        request_key (typing.Hashable): The request_key to delete the file for.\n    Returns:\n        None\n    \"\"\"\n\n    saving_path = os.path.join(self.path, hasher(request_key))\n    if os.path.exists(saving_path):\n        os.remove(saving_path)\n</code></pre>"},{"location":"modules/#stuff_saver.StuffSaver.exists","title":"<code>exists(request_key)</code>","text":"<p>Check if the data exists in the temporary folder.</p> <p>Parameters:</p> Name Type Description Default <code>request_key</code> <code>Hashable</code> <p>request_key key to check if the data exists.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the data exists in the temporary folder, False otherwise.</p> Source code in <code>stuff_saver/stuff_saver.py</code> <pre><code>def exists(self, request_key: typing.Hashable) -&gt; bool:\n    \"\"\"Check if the data exists in the temporary folder.\n\n    Args:\n        request_key (typing.Hashable): request_key key to check if the data exists.\n\n    Returns:\n        bool: True if the data exists in the temporary folder, False otherwise.\n    \"\"\"\n\n    saving_path = os.path.join(self.path, hasher(request_key))\n    return os.path.isfile(saving_path)\n</code></pre>"},{"location":"modules/#stuff_saver.StuffSaver.reload","title":"<code>reload(request_key)</code>","text":"<p>Reloads the data associated with the given request_key.</p> <p>Parameters:</p> Name Type Description Default <code>request_key</code> <code>Hashable</code> <p>The request_key to reload the data for.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>typing.Any: The reloaded data.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file associated with the request_key does not exist.</p> <code>IOError</code> <p>If there is an error reading the file.</p> Source code in <code>stuff_saver/stuff_saver.py</code> <pre><code>def reload(self, request_key: typing.Hashable) -&gt; typing.Any:\n    \"\"\"\n    Reloads the data associated with the given request_key.\n\n    Parameters:\n        request_key (typing.Hashable): The request_key to reload the data for.\n\n    Returns:\n        typing.Any: The reloaded data.\n\n    Raises:\n        FileNotFoundError: If the file associated with the request_key does not exist.\n        IOError: If there is an error reading the file.\n\n    \"\"\"\n    saving_path = os.path.join(self.path, hasher(request_key))\n    with open(saving_path, \"rb\") as handle:\n        data = self.backend.load(handle)\n    return data\n</code></pre>"},{"location":"modules/#stuff_saver.StuffSaver.reload_folder","title":"<code>reload_folder()</code>","text":"<p>Reloads the folder specified by <code>self.path</code> and returns a list of previously saved data.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>List[Any]</code> <p>A list of loaded data from the files in the folder.</p> Source code in <code>stuff_saver/stuff_saver.py</code> <pre><code>def reload_folder(self) -&gt; typing.List[typing.Any]:\n    \"\"\"\n    Reloads the folder specified by `self.path` and returns a list of previously saved data.\n\n    Returns:\n        list: A list of loaded data from the files in the folder.\n    \"\"\"\n    list_data = []\n    for filename in os.listdir(self.path):\n        saving_path = os.path.join(self.path, filename)\n        with open(saving_path, \"rb\") as handle:\n            data = self.backend.load(handle)\n        list_data.append(data)\n    return list_data\n</code></pre>"},{"location":"modules/#stuff_saver.StuffSaver.save","title":"<code>save(request_key, data)</code>","text":"<p>Save the given data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>request_key</code> <code>Hashable</code> <p>The request_key object used to generate the saving path.</p> required <code>data</code> <code>Any</code> <p>The data to be saved.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>stuff_saver/stuff_saver.py</code> <pre><code>def save(self, request_key: typing.Hashable, data: typing.Any) -&gt; None:\n    \"\"\"\n    Save the given data to a file.\n\n    Args:\n        request_key (typing.Hashable): The request_key object used to generate the saving path.\n        data (typing.Any): The data to be saved.\n\n    Returns:\n        None\n    \"\"\"\n    saving_path = os.path.join(self.path, hasher(request_key))\n    with open(saving_path, \"wb\") as handle:\n        self.backend.dump(data, handle)\n</code></pre>"},{"location":"modules/#stuff_saver.StuffSaver.wrap","title":"<code>wrap(request_key, fn, *args, **kwargs)</code>","text":"<p>Wraps a function call with caching mechanism. Args:     request_key (typing.Hashable): The key used to identify the cached result.     fn (callable): The function to be wrapped.     args: Positional arguments to be passed to the function.     *kwargs: Keyword arguments to be passed to the function. Returns:     typing.Any: The result of the function call. Example:     &gt;&gt;&gt; def add(a, b):     ...     return a + b     ...     &gt;&gt;&gt; ss = StuffSaver()     &gt;&gt;&gt; wrapped_add = ss.wrap(\"add\", add, 2, 3)     &gt;&gt;&gt; print(wrapped_add)     5</p> Source code in <code>stuff_saver/stuff_saver.py</code> <pre><code>def wrap(\n    self,\n    #\n    request_key: typing.Hashable,\n    fn: typing.Callable[..., typing.Any],\n    *args: typing.Any,\n    **kwargs: dict[str, typing.Any],\n) -&gt; typing.Any:\n    \"\"\"\n    Wraps a function call with caching mechanism.\n    Args:\n        request_key (typing.Hashable): The key used to identify the cached result.\n        fn (callable): The function to be wrapped.\n        *args: Positional arguments to be passed to the function.\n        **kwargs: Keyword arguments to be passed to the function.\n    Returns:\n        typing.Any: The result of the function call.\n    Example:\n        &gt;&gt;&gt; def add(a, b):\n        ...     return a + b\n        ...\n        &gt;&gt;&gt; ss = StuffSaver()\n        &gt;&gt;&gt; wrapped_add = ss.wrap(\"add\", add, 2, 3)\n        &gt;&gt;&gt; print(wrapped_add)\n        5\n    \"\"\"\n\n    if self.exists(request_key):\n        return self.reload(request_key)\n    else:\n        result = fn(*args, **kwargs)\n        self.save(request_key, result)\n        return result\n</code></pre>"},{"location":"modules/#stuff_saver.hasher","title":"<code>hasher(word)</code>","text":"<p>Hashes a given word and returns the hashed value.</p> <p>Parameters: - word (typing.Hashable): The word to be hashed.</p> <p>Returns: - str: The hashed value of the word.</p> Source code in <code>stuff_saver/utils.py</code> <pre><code>def hasher(word: typing.Hashable) -&gt; str:\n    \"\"\"\n    Hashes a given word and returns the hashed value.\n\n    Parameters:\n    - word (typing.Hashable): The word to be hashed.\n\n    Returns:\n    - str: The hashed value of the word.\n    \"\"\"\n\n    slug_word = slugify(str(word))\n    hash_object = hashlib.sha512(slug_word.encode())\n    slug_word = hash_object.hexdigest()\n    return slug_word\n</code></pre>"},{"location":"modules/#stuff_saver.mkdir_p","title":"<code>mkdir_p(path)</code>","text":"<p>Create a directory and its parent directories if they do not exist. Args:     path (str): The path of the directory to be created. Raises:     OSError: If an error occurs while creating the directory.</p> Source code in <code>stuff_saver/utils.py</code> <pre><code>def mkdir_p(path: str) -&gt; None:\n    \"\"\"\n    Create a directory and its parent directories if they do not exist.\n    Args:\n        path (str): The path of the directory to be created.\n    Raises:\n        OSError: If an error occurs while creating the directory.\n    \"\"\"\n\n    try:\n        os.makedirs(path)\n    except OSError as exc:  # Python &gt;2.5\n        if exc.errno == errno.EEXIST and os.path.isdir(path):\n            pass\n        else:\n            raise\n</code></pre>"},{"location":"modules/#stuff_saver.slugify","title":"<code>slugify(value, lower=True)</code>","text":"<p>Convert a string into a slug by removing special characters and replacing spaces with hyphens.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The string to be slugified.</p> required <code>lower</code> <code>bool</code> <p>Whether to convert the slug to lowercase. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The slugified string.</p> Source code in <code>stuff_saver/utils.py</code> <pre><code>def slugify(value: str, lower: bool = True) -&gt; str:\n    \"\"\"\n    Convert a string into a slug by removing special characters and replacing spaces with hyphens.\n\n    Args:\n        value (str): The string to be slugified.\n        lower (bool, optional): Whether to convert the slug to lowercase. Defaults to True.\n\n    Returns:\n        str: The slugified string.\n    \"\"\"\n\n    value_bytes: bytes = unicodedata.normalize(\"NFKD\", value).encode(\"utf-8\", \"ignore\")\n    value = re.sub(r\"[^\\w\\s-]\", \"\", value_bytes.decode(\"utf-8\")).strip()\n    if lower:\n        value = value.lower()\n    value = str(re.sub(r\"[-\\s]+\", \"-\", value))\n    return value\n</code></pre>"}]}